<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NFP Example Software: /home/nfp/gavin/nfp-common/host/src/nfp_support.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NFP Example Software
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4f7e4242e27b8c8b476722507617a881.html">host</a></li><li class="navelem"><a class="el" href="dir_ee436fe9bbd694a1f99c2ca92ae2568f.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">nfp_support.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>NFP support library.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;fcntl.h&gt;</code><br/>
<code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;hugetlbfs.h&gt;</code><br/>
</div>
<p><a href="nfp__support_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnfp__cppid.html">nfp_cppid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afe592668975ef18d9dbec544556272b5"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#afe592668975ef18d9dbec544556272b5">nfp_init</a> (int device_num)</td></tr>
<tr class="memdesc:afe592668975ef18d9dbec544556272b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize an NFP structure for use, attaching to an NFP if required.  <a href="#afe592668975ef18d9dbec544556272b5">More...</a><br/></td></tr>
<tr class="separator:afe592668975ef18d9dbec544556272b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e4dee9b66ab50d5cf378be5bae8568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#ae0e4dee9b66ab50d5cf378be5bae8568">nfp_shutdown</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>)</td></tr>
<tr class="memdesc:ae0e4dee9b66ab50d5cf378be5bae8568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the NFP chip structure, making it available for others.  <a href="#ae0e4dee9b66ab50d5cf378be5bae8568">More...</a><br/></td></tr>
<tr class="separator:ae0e4dee9b66ab50d5cf378be5bae8568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4d3bf8e59c90ca032e016148524c68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#a3b4d3bf8e59c90ca032e016148524c68">nfp_fw_load</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, const char *filename)</td></tr>
<tr class="memdesc:a3b4d3bf8e59c90ca032e016148524c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load firmware onto an NFP, without starting it.  <a href="#a3b4d3bf8e59c90ca032e016148524c68">More...</a><br/></td></tr>
<tr class="separator:a3b4d3bf8e59c90ca032e016148524c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f762a72a4a170fabae297a61772dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#af4f762a72a4a170fabae297a61772dc4">nfp_fw_unload</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>)</td></tr>
<tr class="memdesc:af4f762a72a4a170fabae297a61772dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unload firmware from an NFP.  <a href="#af4f762a72a4a170fabae297a61772dc4">More...</a><br/></td></tr>
<tr class="separator:af4f762a72a4a170fabae297a61772dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240ec390b55cf7cc90091c48d198988d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#a240ec390b55cf7cc90091c48d198988d">nfp_fw_start</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>)</td></tr>
<tr class="memdesc:a240ec390b55cf7cc90091c48d198988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start firmware that has been loaded.  <a href="#a240ec390b55cf7cc90091c48d198988d">More...</a><br/></td></tr>
<tr class="separator:a240ec390b55cf7cc90091c48d198988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c2cd1b0f75b403397819e8a935d59c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#aa1c2cd1b0f75b403397819e8a935d59c">nfp_shm_alloc</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, const char *shm_filename, int shm_key, size_t size, int create)</td></tr>
<tr class="memdesc:aa1c2cd1b0f75b403397819e8a935d59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate some shared memory (one area per NFP)  <a href="#aa1c2cd1b0f75b403397819e8a935d59c">More...</a><br/></td></tr>
<tr class="separator:aa1c2cd1b0f75b403397819e8a935d59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacdcd050ad4bd264b004e706e516116"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#abacdcd050ad4bd264b004e706e516116">nfp_shm_data</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>)</td></tr>
<tr class="memdesc:abacdcd050ad4bd264b004e706e516116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to NFP SHM data allocated with <code>nfp_shm_alloc</code>.  <a href="#abacdcd050ad4bd264b004e706e516116">More...</a><br/></td></tr>
<tr class="separator:abacdcd050ad4bd264b004e706e516116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083bc9e655621255061caaec852b827a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#a083bc9e655621255061caaec852b827a">nfp_shm_close</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>)</td></tr>
<tr class="memdesc:a083bc9e655621255061caaec852b827a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the shared memory corresponding to the NFP device.  <a href="#a083bc9e655621255061caaec852b827a">More...</a><br/></td></tr>
<tr class="separator:a083bc9e655621255061caaec852b827a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fcec2ce344079da97314882c235a2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#a83fcec2ce344079da97314882c235a2e">nfp_huge_malloc</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, void **ptr, size_t byte_size)</td></tr>
<tr class="memdesc:a83fcec2ce344079da97314882c235a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Malloc using hugepages and get pointer to it.  <a href="#a83fcec2ce344079da97314882c235a2e">More...</a><br/></td></tr>
<tr class="separator:a83fcec2ce344079da97314882c235a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cde0eef3936237d238f6e22ece11974"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#a2cde0eef3936237d238f6e22ece11974">nfp_huge_physical_address</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, void *ptr, uint64_t ofs)</td></tr>
<tr class="memdesc:a2cde0eef3936237d238f6e22ece11974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find physical address of an offset into a huge malloc region.  <a href="#a2cde0eef3936237d238f6e22ece11974">More...</a><br/></td></tr>
<tr class="separator:a2cde0eef3936237d238f6e22ece11974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e0003a428a7a1c33ed53f2c9fba0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#ab6e0003a428a7a1c33ed53f2c9fba0d1">nfp_huge_free</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, void *ptr)</td></tr>
<tr class="memdesc:ab6e0003a428a7a1c33ed53f2c9fba0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a hugepage allocation.  <a href="#ab6e0003a428a7a1c33ed53f2c9fba0d1">More...</a><br/></td></tr>
<tr class="separator:ab6e0003a428a7a1c33ed53f2c9fba0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a19bc990f792422e9a61d3719276d83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a19bc990f792422e9a61d3719276d83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>nfp_show_rtsyms</b> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>)</td></tr>
<tr class="separator:a5a19bc990f792422e9a61d3719276d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add16739b69bb7427f6941dbb7b52e571"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#add16739b69bb7427f6941dbb7b52e571">nfp_get_rtsym_cppid</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, const char *sym_name, struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> *cppid)</td></tr>
<tr class="memdesc:add16739b69bb7427f6941dbb7b52e571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a run-time symbol and fill an <a class="el" href="structnfp__cppid.html">nfp_cppid</a> for accessing it.  <a href="#add16739b69bb7427f6941dbb7b52e571">More...</a><br/></td></tr>
<tr class="separator:add16739b69bb7427f6941dbb7b52e571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823dfdd879d056c492e67da7c044d2a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#a823dfdd879d056c492e67da7c044d2a6">nfp_write</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> *cppid, int offset, void *data, ssize_t size)</td></tr>
<tr class="memdesc:a823dfdd879d056c492e67da7c044d2a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to an NFP memory or register.  <a href="#a823dfdd879d056c492e67da7c044d2a6">More...</a><br/></td></tr>
<tr class="separator:a823dfdd879d056c492e67da7c044d2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64a6a654d67f0a8b4095c50013574d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="nfp__support_8h.html#ae64a6a654d67f0a8b4095c50013574d6">nfp_read</a> (struct <a class="el" href="structnfp.html">nfp</a> *<a class="el" href="structnfp.html">nfp</a>, struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> *cppid, int offset, void *data, ssize_t size)</td></tr>
<tr class="memdesc:ae64a6a654d67f0a8b4095c50013574d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from an NFP memory or register.  <a href="#ae64a6a654d67f0a8b4095c50013574d6">More...</a><br/></td></tr>
<tr class="separator:ae64a6a654d67f0a8b4095c50013574d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>NFP support library. </p>
<p>Copyright (C) 2015-2016, Gavin J Stark. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>This library abstracts some of the Netronome NFP library calls to make host applications a little simpler.</p>
<p>For example, the NFP device opening and closing is wrapped in the library, adding atexit handlers and so on, so that firmware and NFPs are handled cleanly. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a3b4d3bf8e59c90ca032e016148524c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_fw_load </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load firmware onto an NFP, without starting it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of NFP device to unload firmware for</td></tr>
    <tr><td class="paramname">filename</td><td>Full filename of file to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt;0 on failure</dd></dl>
<p>Load firmware from an 'nffw' file </p>

</div>
</div>
<a class="anchor" id="a240ec390b55cf7cc90091c48d198988d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_fw_start </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start firmware that has been loaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of NFP device that has firmware loaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error</dd></dl>
<p>Start all the firmware that has been loaded </p>

</div>
</div>
<a class="anchor" id="af4f762a72a4a170fabae297a61772dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nfp_fw_unload </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unload firmware from an NFP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of NFP device to unload firmware for</td></tr>
  </table>
  </dd>
</dl>
<p>Unload any loaded firmware; if no firmware has been loaded then this does nothing </p>

</div>
</div>
<a class="anchor" id="add16739b69bb7427f6941dbb7b52e571"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_get_rtsym_cppid </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sym_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> *&#160;</td>
          <td class="paramname"><em>cppid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a run-time symbol and fill an <a class="el" href="structnfp__cppid.html">nfp_cppid</a> for accessing it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>Nfp with loaded firmware whose run-time symbols are to be interrogated</td></tr>
    <tr><td class="paramname">sym_nam</td><td>Symbol name</td></tr>
    <tr><td class="paramname">cppid</td><td>Structure to store result in, used for later read/write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on failure (e.g. symbol not found), 0 for success</dd></dl>
<p>Read a run-time symbol and derive a struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> to use for reading/writing. The firmware need not have been started, just loaded. </p>

</div>
</div>
<a class="anchor" id="ab6e0003a428a7a1c33ed53f2c9fba0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nfp_huge_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a hugepage allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure already initialized</td></tr>
    <tr><td class="paramname">ptr</td><td>Huge page allocation previous returned by nfp_huge_malloc</td></tr>
  </table>
  </dd>
</dl>
<p>Free a huge page allocation previous allocated by <code>nfp_huge_malloc</code> </p>

</div>
</div>
<a class="anchor" id="a83fcec2ce344079da97314882c235a2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_huge_malloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Malloc using hugepages and get pointer to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure already initialized</td></tr>
    <tr><td class="paramname">ptr</td><td>Pointer to store (process virtual) allocated memory ptr in</td></tr>
    <tr><td class="paramname">byte_size</td><td>Byte size to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>amount of memory allocated</dd></dl>
<p>Allocate huge pages with <code>get_huge_pages</code>, and ensure it is mapped. </p>

</div>
</div>
<a class="anchor" id="a2cde0eef3936237d238f6e22ece11974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t nfp_huge_physical_address </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find physical address of an offset into a huge malloc region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure already initialized</td></tr>
    <tr><td class="paramname">ptr</td><td>Previously nfp_huge_malloc pointer</td></tr>
    <tr><td class="paramname">ofs</td><td>Offset from pointer to find address</td></tr>
  </table>
  </dd>
</dl>
<p>This function for Ubuntu LTS14.04 uses a /proc/self/pagemap hack to find the physical address for a process virtual address </p>

</div>
</div>
<a class="anchor" id="afe592668975ef18d9dbec544556272b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structnfp.html">nfp</a>* nfp_init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>device_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize an NFP structure for use, attaching to an NFP if required. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_num</td><td>NFP device number to attach to (-1 =&gt; none)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on error, otherwise an allocated NFP structure</dd></dl>
<p>Initialize NFP structure, attaching to specified device number</p>
<p>For clients that do not interact directly with an NFP the device number should be -1. The device number should only be non-negative for a server thread that is to directly interact with an NFP (for example to load firmware). (Many client interactions with an NFP will take place using host memory alone.)</p>
<p>Adds atexit handler to shut down NFP cleanly at exit if required. </p>

</div>
</div>
<a class="anchor" id="ae64a6a654d67f0a8b4095c50013574d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_read </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> *&#160;</td>
          <td class="paramname"><em>cppid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from an NFP memory or register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>Nfp structure</td></tr>
    <tr><td class="paramname">cppid</td><td><a class="el" href="structnfp__cppid.html">nfp_cppid</a> structure filled in, for example, by nfp_get_rtsym_cppid</td></tr>
    <tr><td class="paramname">offset</td><td>address offset from start of CPP ID to write at (may be outside symbol)</td></tr>
    <tr><td class="paramname">data</td><td>Data buffer to place read data into</td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes of data to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
<a class="anchor" id="aa1c2cd1b0f75b403397819e8a935d59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_shm_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>shm_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>shm_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>create</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate some shared memory (one area per NFP) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of NFP device to allocate SHM for</td></tr>
    <tr><td class="paramname">shm_filename</td><td>Filename for a shared memory 'lock' file</td></tr>
    <tr><td class="paramname">shm_key</td><td>32-bit key used with filename for SHM 'key'</td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes of memory to create (if create is non-zero)</td></tr>
    <tr><td class="paramname">create</td><td>Non-zero if SHM should be created if it does not exist</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes allocated in shared memory</dd></dl>
<p>This function allocates shared memory of <code>size</code> bytes, using the <code>shm_filename</code> and <code>shm_key</code> to define a system-wide shared memory handle so that multiple processes may share the same memory.</p>
<p>Only a single shared memory is permitted per NFP structure.</p>
<p>Generally the server will invoke this call with <code>create</code> set to a vaue of 1. Clients then start up, connect to the server, and call this function with create set to 0 (but the rest of the arguments the same, except size is ignored) </p>

</div>
</div>
<a class="anchor" id="a083bc9e655621255061caaec852b827a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nfp_shm_close </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the shared memory corresponding to the NFP device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of NFP device to close SHM for</td></tr>
  </table>
  </dd>
</dl>
<p>Close the shared memory previousa allocated with <code>nfp_shm_alloc</code> </p>

</div>
</div>
<a class="anchor" id="abacdcd050ad4bd264b004e706e516116"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nfp_shm_data </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to NFP SHM data allocated with <code>nfp_shm_alloc</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of NFP device to get SHM pointer of</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to (process virtual) address of shared memory allocated by <code>nfp_shm_alloc</code> </dd></dl>
<p>Get SHM data pointer after it has been allocated </p>

</div>
</div>
<a class="anchor" id="ae0e4dee9b66ab50d5cf378be5bae8568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nfp_shutdown </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the NFP chip structure, making it available for others. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>NFP structure of device to shut down</td></tr>
  </table>
  </dd>
</dl>
<p>Shutdown the NFP, unloading firmware before closing the device Performs an incremental shutdown of the activated components, and can be performed many times successively without failure Removes the NFP from the list to be shutdown at exit </p>

</div>
</div>
<a class="anchor" id="a823dfdd879d056c492e67da7c044d2a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int nfp_write </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structnfp.html">nfp</a> *&#160;</td>
          <td class="paramname"><em>nfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structnfp__cppid.html">nfp_cppid</a> *&#160;</td>
          <td class="paramname"><em>cppid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to an NFP memory or register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nfp</td><td>Nfp structure</td></tr>
    <tr><td class="paramname">cppid</td><td><a class="el" href="structnfp__cppid.html">nfp_cppid</a> structure filled in, for example, by nfp_get_rtsym_cppid</td></tr>
    <tr><td class="paramname">offset</td><td>address offset from start of CPP ID to write at (may be outside symbol)</td></tr>
    <tr><td class="paramname">data</td><td>Data to write</td></tr>
    <tr><td class="paramname">size</td><td>Size in bytes of data to write</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:36:17 for NFP Example Software by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
