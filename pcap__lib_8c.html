<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NFP Example Software: /home/nfp/gavin/nfp-common/firmware/app/pcap_lib.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NFP Example Software
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d9edf6c004b4a7ff14fe9ae7a92214ee.html">firmware</a></li><li class="navelem"><a class="el" href="dir_73d8daca1cbf5b0779bcb86e18cd3f5d.html">app</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pcap_lib.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple packet capture system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="me_8h_source.html">nfp/me.h</a>&gt;</code><br/>
<code>#include &lt;nfp/mem.h&gt;</code><br/>
<code>#include &lt;nfp/cls.h&gt;</code><br/>
<code>#include &lt;nfp/pcie.h&gt;</code><br/>
<code>#include &lt;nfp/types.h&gt;</code><br/>
<code>#include &lt;nfp.h&gt;</code><br/>
<code>#include &lt;nfp_override.h&gt;</code><br/>
<code>#include &quot;firmware/pcap.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="pcap__lib_8h_source.html">pcap_lib.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structctm__pkt__hdr.html">ctm_pkt_hdr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpkt__buf__desc.html">pkt_buf_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmu__buf__desc.html">mu_buf_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmu__buf__to__host__dma__work.html">mu_buf_to_host_dma_work</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmu__buf__dma__desc.html">mu_buf_dma_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhost__data.html">host_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcie__buf__desc.html">pcie_buf_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:adfbe1b4bf747a70b91d10608c189c4ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#adfbe1b4bf747a70b91d10608c189c4ed">U32_LINK_SYM</a>(symname, shift)&#160;&#160;&#160;((uint32_t)(((uint64_t)__link_sym(#symname))&gt;&gt;shift))</td></tr>
<tr class="separator:adfbe1b4bf747a70b91d10608c189c4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd80f5f36762ccee0dc88d35703a396d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd80f5f36762ccee0dc88d35703a396d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CTM_PKT_OFFSET</b>&#160;&#160;&#160;(64)</td></tr>
<tr class="separator:afd80f5f36762ccee0dc88d35703a396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60da20bb16f42d998b0a22a108f82d38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60da20bb16f42d998b0a22a108f82d38"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX_CTM_DMAS_IN_PROGRESS</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a60da20bb16f42d998b0a22a108f82d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a582613a7b96a5f679a1065f9360316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a582613a7b96a5f679a1065f9360316"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>DMA_MAX_BURST</b>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:a4a582613a7b96a5f679a1065f9360316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b79659a66b3d6c906f32715bf539d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6b79659a66b3d6c906f32715bf539d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QDEF_MU_BUF_RECYCLE</b>&#160;&#160;&#160;pcap_mu_buf_recycle,10,16,i24.emem</td></tr>
<tr class="separator:ae6b79659a66b3d6c906f32715bf539d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b07f8dc682d0ee6a4c3c4b017a21c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6b07f8dc682d0ee6a4c3c4b017a21c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QDEF_MU_BUF_IN_USE</b>&#160;&#160;&#160;pcap_mu_buf_in_use,10,17,i24.emem</td></tr>
<tr class="separator:af6b07f8dc682d0ee6a4c3c4b017a21c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde28e093464fc55c6ecaeba67ac89ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afde28e093464fc55c6ecaeba67ac89ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QDEF_MU_BUF_ALLOC</b>&#160;&#160;&#160;pcap_mu_buf_alloc,11,18,i24.emem</td></tr>
<tr class="separator:afde28e093464fc55c6ecaeba67ac89ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d00a465d7a1364892bc031115f302e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d00a465d7a1364892bc031115f302e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QDEF_TO_HOST_DMA</b>&#160;&#160;&#160;pcap_to_host_dma,11,19,i24.emem</td></tr>
<tr class="separator:a8d00a465d7a1364892bc031115f302e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870b5148107e0d9a97777fb6c60f932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab870b5148107e0d9a97777fb6c60f932"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>QDEF_DEBUG_JOURNAL</b>&#160;&#160;&#160;pcap_debug_journal,16,24,i24.emem</td></tr>
<tr class="separator:ab870b5148107e0d9a97777fb6c60f932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df44f3b40d1a20b02a64e5942fa88a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7df44f3b40d1a20b02a64e5942fa88a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ALLOC_CLS_HOST_RING</b>()&#160;&#160;&#160;ALLOC_RES(chr,cls_host_ring_base,island,64)</td></tr>
<tr class="separator:a7df44f3b40d1a20b02a64e5942fa88a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a80155586fa275b28773c9b203f52caba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>PKT_BUF_NOT_INIT</b>, 
<b>PKT_BUF_OVERFLOWED</b>, 
<b>PKT_BUF_ALLOCKED</b>
 }</td></tr>
<tr class="separator:a80155586fa275b28773c9b203f52caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44934775d5057efaf7b8d3ad2cd3e981"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#a44934775d5057efaf7b8d3ad2cd3e981">_alloc_mem</a> (&quot;mu_buf_desc_store emem global 8 256&quot;)</td></tr>
<tr class="separator:a44934775d5057efaf7b8d3ad2cd3e981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd63a89d8a979ceb4229fb657c41f5bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#afd63a89d8a979ceb4229fb657c41f5bd">pkt_work_enq</a> (struct <a class="el" href="structpkt__buf__desc.html">pkt_buf_desc</a> *<a class="el" href="structpkt__buf__desc.html">pkt_buf_desc</a>)</td></tr>
<tr class="separator:afd63a89d8a979ceb4229fb657c41f5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f193d7f6136fb8f88b56b63ecf6fee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#af3f193d7f6136fb8f88b56b63ecf6fee">packet_capture_pkt_rx_dma</a> (int poll_interval)</td></tr>
<tr class="separator:af3f193d7f6136fb8f88b56b63ecf6fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fee0ed8d1070c21657db8526b864c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#a5fee0ed8d1070c21657db8526b864c2c">packet_capture_dma_to_host_slave</a> (void)</td></tr>
<tr class="separator:a5fee0ed8d1070c21657db8526b864c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38dc05be5838d350c88ea8f919bc154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#ac38dc05be5838d350c88ea8f919bc154">packet_capture_dma_to_host_master</a> (int poll_interval)</td></tr>
<tr class="separator:ac38dc05be5838d350c88ea8f919bc154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3effacd61c93774284887a5d8aac9045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#a3effacd61c93774284887a5d8aac9045">packet_capture_mu_buffer_recycler</a> (int poll_interval)</td></tr>
<tr class="separator:a3effacd61c93774284887a5d8aac9045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7303aefb6531f876f7eb4af246e5d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#aa7303aefb6531f876f7eb4af246e5d39">packet_capture_fill_mu_buffer_list</a> (uint32_t mu_base_s8, int num_buf)</td></tr>
<tr class="separator:aa7303aefb6531f876f7eb4af246e5d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f85b25fa490ab889e8953f6984c01a3"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#a7f85b25fa490ab889e8953f6984c01a3">packet_capture_init_pkt_rx_dma</a> (void)</td></tr>
<tr class="separator:a7f85b25fa490ab889e8953f6984c01a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df596ec8a6328c4b0d58ed1f53594c5"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#a4df596ec8a6328c4b0d58ed1f53594c5">packet_capture_init_mu_buffer_recycler</a> (void)</td></tr>
<tr class="separator:a4df596ec8a6328c4b0d58ed1f53594c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa499134067603cf522c681cebdb1b98a"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#aa499134067603cf522c681cebdb1b98a">packet_capture_init_dma_to_host_master</a> (void)</td></tr>
<tr class="separator:aa499134067603cf522c681cebdb1b98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4a68d318b96f54e5337448669bc33f"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8c.html#aec4a68d318b96f54e5337448669bc33f">packet_capture_init_dma_to_host_slave</a> (void)</td></tr>
<tr class="separator:aec4a68d318b96f54e5337448669bc33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simple packet capture system. </p>
<p>Copyright (C) 2015, Gavin J Stark. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>This is a library to support a PCAP packet capture to a host x86 system</p>
<p>The host delivers buffers to the CLS of the PCI island; it has a software ring with a write ptr written by the host. The software ring contains entries of the form 64-bit PCIe address. A thread reads these buffers from the hosts and pairs them with internal MU buffers. The MU buffers are used to hold received packets, and the buffer contents are DMAed into the paired host buffer.</p>
<p>Packets are received by the hardware solely into CTM, and then have to be DMAed in to an portion of one of the MU buffers. The MU buffer is distributed using a buffer allocation system based on contiguously allocating memory for the packets ordered by the allocation requests.</p>
<p>The MU buffer allocation uses a simple structure containing the base address in MU addressing of the buffer base, a packet number and the next offset to be allocated.</p>
<p>An allocation is performed by incrementing the packet number and adding the allocation to the buffer offset. This is performed with a saturating add operation, of length 2 32-bit words. The packet number and buffer offset are placed as the top-most fields of the two 32-bit words, and so saturation protects from overflow.</p>
<p>Using a test-and-add-sat provides the allocator with the allocation while moving the buffer descriptor on appropriately.</p>
<p>Using 256kB MU buffers aligned to 256kB requires a 22-bit MU address, and it can take 128 2kB packets or 2k 64B packets.</p>
<p>The front of the MU buffer contains: A bit mask of the packets that have completed DMA (atomic sets) Descriptors of the packets that have completed DMA (bulk writes)</p>
<p>The host buffers must be multiples of 256kB as they are paired with the 256kB MU buffers.</p>
<p>The to-host DMA process consists of a master thread which takes control of an MU buffer and it monitors the bit-mask of packets ready. It then packages up DMAs: PCIe base, MU base, first packet, last packet, first offset, last offset, and presents them as work to slave DMA threads When the MU buffer is completed and all the DMA threads complete the MU buffer can be recycled.</p>
<p>The buffer recycling thread manages the 256kB PCIe buffer allocation, using a CLS memory as a ring. The buffers from the host are consumed in the order that they are presented. It pairs the PCIe buffers with MU buffers from a free pool. Before the MU buffer is presented for allocation its header must be zeroed as that contains the bit-mask of ready packets. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="adfbe1b4bf747a70b91d10608c189c4ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U32_LINK_SYM</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">symname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">shift&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((uint32_t)(((uint64_t)__link_sym(#symname))&gt;&gt;shift))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IncludesDefines </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a44934775d5057efaf7b8d3ad2cd3e981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_alloc_mem </td>
          <td>(</td>
          <td class="paramtype">&quot;mu_buf_desc_store emem global 8 256&quot;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Static data used globally struct cls_ctm_dma_credit</p>
<p>Stored in CLS, this is a CTM DMA credit management structure. It is initialized to zero, then the number of outstanding CTM DMAs is next_claimant-last_complete. A thread wishing to do a DMA test-and-increments next_claimant, getting its claimant number. When its claimant number is less than last_complete+max_ctm_dmas it may DMA. When it completes it increments last_complete. </p>

</div>
</div>
<a class="anchor" id="ac38dc05be5838d350c88ea8f919bc154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_dma_to_host_master </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poll_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_dma_to_host_master</p>
<p>This thread takes control of an MU buffer after it starts to be used, and manages DMA of the whole buffer over time to the host.</p>
<p>It starts operating when it receives an MU buffer from the first allocator, using the mu_buf_in_use work queue.</p>
<p>It monitors the bit-mask of packets ready in the MU buffer. It then packages up DMAs for slaves: PCIe base, MU base, first packet, number of packets, and presents them as work to DMA slave threads. When the MU buffer is completed and all the DMA threads complete the MU buffer can be recycled.</p>
<p>It has a 'first packet' which is set to 0 initially. It monitors up to 64 bits from 'first packet' of the bitmask of completed packets. When the bit for 'first packet' is set, it counts the number of consecutive set bits from that one upwards, and adds a DMA of that size (therefore of up to 64 packets). It then moves on 'first_packet'</p>
<p>If the bit is not set for 'first packet', the thread reads 'total_packets'; this is set when the receivers complete using the MU buffer. If 'first packet' is equal to 'total_packets' then the buffer is done; if not, sleep and poll the bitmask again.</p>
<p>When the buffer is done, the thread waits for all the DMAs to complete and then the MU buffer is recycled </p>

</div>
</div>
<a class="anchor" id="a5fee0ed8d1070c21657db8526b864c2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_dma_to_host_slave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_dma_to_host_slave - 292i + 5450d (128 64B pkt/10 1.5kB pkt) 20i + 20i + 300d + 8*28i + 8*100d + 8*500d + 1*28i + 1*100d + 1*250d for 16kB transfer = 292i + 5450d</p>
<p>At most 64 packets - need to redo a bit of calculation here for 128 64B packets (2us), or for 10 1.5kB packets (3us?)</p>
<p>Takes ~5% CPU per thread at full load</p>
<p>The DMA threads put themselves on the DMA work queue, and take the data from the DMA master thread. They issue a DMA (or number of DMAs) to move the packet data, and then they issue a DMA to move the packet descriptor data. When the DMAs complete they increment the 'dmas complete' in the master thread structure and add themselves back to the DMA work queue. </p>

</div>
</div>
<a class="anchor" id="aa7303aefb6531f876f7eb4af246e5d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_fill_mu_buffer_list </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mu_base_s8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_fill_mu_buffer_list</p>
<p>Fill the MU buffer list with 'num_buf' 256kB buffers starting at given base</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu_base_s8</td><td>MU buffer base address &gt;&gt; 8 </td></tr>
    <tr><td class="paramname">num_buf</td><td>Number of 256kB buffers to fill with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa499134067603cf522c681cebdb1b98a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_dma_to_host_master </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_dma_to_host_master</p>
<p>Perform initialization for the DMA to host master</p>
<p>Writes configuration of the MU_BUF_RECYCLE, TO_HOST_DMA and MU_BUF_IN_USE queues </p>

</div>
</div>
<a class="anchor" id="aec4a68d318b96f54e5337448669bc33f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_dma_to_host_slave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_dma_to_host_slave</p>
<p>Perform initialization for the DMA to host slave</p>
<p>Gets TO_HOST_DMA queue configuration for the thread </p>

</div>
</div>
<a class="anchor" id="a4df596ec8a6328c4b0d58ed1f53594c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_mu_buffer_recycler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_mu_buffer_recycler</p>
<p>Perform initialization for the MU buffer recycler</p>
<p>Writes configuration of the MU_BUF_ALLOC queue Gets queue configuration required by the threads </p>

</div>
</div>
<a class="anchor" id="a7f85b25fa490ab889e8953f6984c01a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_pkt_rx_dma </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_pkt_rx_dma</p>
<p>Perform initialization for the packet rx DMA threads</p>
<p>Gets queue configuration required by the threads </p>

</div>
</div>
<a class="anchor" id="a3effacd61c93774284887a5d8aac9045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_mu_buffer_recycler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poll_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_mu_buffer_recycler - ?</p>
<p>Get PCIe buffers from the host, collect with recycled buffers, then add them to the muq_mu_buf_alloc workq.</p>
<p>If an MU buffer lasts for 1k 64B packets then this needs to run every ~8k cycles.</p>
<p>If an MU buffer lasts for 256kB=2Mbits of data then this needs to run every ~20k cycles.</p>
<p>The max utilization of the ME is &lt;1%. </p>

</div>
</div>
<a class="anchor" id="af3f193d7f6136fb8f88b56b63ecf6fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_pkt_rx_dma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poll_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_pkt_rx_dma - 89i + 707d + pktB/4 10i + 200d + 40i + 157d + 16i + 150d + 100d + pktB/4 + 16i + 100d + 7i Estimate of 1 thread does 1Mpps max, 8 thread can run per ME</p>
<p>Need 64 threads for min pkt 40GbE, spread across many CTM for bandwidth sharing Could remove DMA credit handling if &lt;64 threads per CTM</p>
<p>Handle packet received by CTM; claim next part of MU buffer, DMA the packet in, then pass on to work queue and free the packet </p>

</div>
</div>
<a class="anchor" id="afd63a89d8a979ceb4229fb657c41f5bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pkt_work_enq </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpkt__buf__desc.html">pkt_buf_desc</a> *&#160;</td>
          <td class="paramname"><em>pkt_buf_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>pkt_work_enq - 16i + 100d 16 inst, 2 parallel mu buf write+atomic set</p>
<p>Set the MU buffer descriptor to indicate that a packet has been received fully. Writes the descriptor and sets the relevant bit.</p>
<p>There is a subtle potential race condition here, between the write of the packet buffer descriptor, and the packet 'ready' bitmask bit being set, the DMA master reading it, then the DMA master then reading the packet buffer descriptor.</p>
<p>This could be avoided if the mem[write] and mem[set] were serialized</p>
<p>However, this seems quite unnecessary at this point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="structpkt__buf__desc.html">pkt_buf_desc</a></td><td>Packet buffer descriptor to mark </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:36:17 for NFP Example Software by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
