<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>NFP Example Software: /home/nfp/gavin/nfp-common/firmware/app/pcap_lib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">NFP Example Software
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d9edf6c004b4a7ff14fe9ae7a92214ee.html">firmware</a></li><li class="navelem"><a class="el" href="dir_73d8daca1cbf5b0779bcb86e18cd3f5d.html">app</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pcap_lib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple packet capture system.  
<a href="#details">More...</a></p>

<p><a href="pcap__lib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a22a976940419d31f53e00e04f0c65f3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#a22a976940419d31f53e00e04f0c65f3e">PKT_CAP_MU_BUF_SHIFT</a>&#160;&#160;&#160;18</td></tr>
<tr class="separator:a22a976940419d31f53e00e04f0c65f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bd7a4bc0d3ed4d8c5880cd8c057204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21bd7a4bc0d3ed4d8c5880cd8c057204"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PKT_CAP_MU_BUF_SIZE</b>&#160;&#160;&#160;(1&lt;&lt;<a class="el" href="pcap__lib_8h.html#a22a976940419d31f53e00e04f0c65f3e">PKT_CAP_MU_BUF_SHIFT</a>)</td></tr>
<tr class="separator:a21bd7a4bc0d3ed4d8c5880cd8c057204"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af3f193d7f6136fb8f88b56b63ecf6fee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#af3f193d7f6136fb8f88b56b63ecf6fee">packet_capture_pkt_rx_dma</a> (int poll_interval)</td></tr>
<tr class="separator:af3f193d7f6136fb8f88b56b63ecf6fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3effacd61c93774284887a5d8aac9045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#a3effacd61c93774284887a5d8aac9045">packet_capture_mu_buffer_recycler</a> (int poll_interval)</td></tr>
<tr class="separator:a3effacd61c93774284887a5d8aac9045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fee0ed8d1070c21657db8526b864c2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#a5fee0ed8d1070c21657db8526b864c2c">packet_capture_dma_to_host_slave</a> (void)</td></tr>
<tr class="separator:a5fee0ed8d1070c21657db8526b864c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38dc05be5838d350c88ea8f919bc154"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#ac38dc05be5838d350c88ea8f919bc154">packet_capture_dma_to_host_master</a> (int poll_interval)</td></tr>
<tr class="separator:ac38dc05be5838d350c88ea8f919bc154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7303aefb6531f876f7eb4af246e5d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#aa7303aefb6531f876f7eb4af246e5d39">packet_capture_fill_mu_buffer_list</a> (uint32_t mu_base_s8, int num_buf)</td></tr>
<tr class="separator:aa7303aefb6531f876f7eb4af246e5d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f85b25fa490ab889e8953f6984c01a3"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#a7f85b25fa490ab889e8953f6984c01a3">packet_capture_init_pkt_rx_dma</a> (void)</td></tr>
<tr class="separator:a7f85b25fa490ab889e8953f6984c01a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df596ec8a6328c4b0d58ed1f53594c5"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#a4df596ec8a6328c4b0d58ed1f53594c5">packet_capture_init_mu_buffer_recycler</a> (void)</td></tr>
<tr class="separator:a4df596ec8a6328c4b0d58ed1f53594c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa499134067603cf522c681cebdb1b98a"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#aa499134067603cf522c681cebdb1b98a">packet_capture_init_dma_to_host_master</a> (void)</td></tr>
<tr class="separator:aa499134067603cf522c681cebdb1b98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4a68d318b96f54e5337448669bc33f"><td class="memItemLeft" align="right" valign="top">__intrinsic void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pcap__lib_8h.html#aec4a68d318b96f54e5337448669bc33f">packet_capture_init_dma_to_host_slave</a> (void)</td></tr>
<tr class="separator:aec4a68d318b96f54e5337448669bc33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simple packet capture system. </p>
<p>Copyright (C) 2015, Gavin J Stark. All rights reserved.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>This is a library to support a PCAP packet capture to a host x86 system </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a22a976940419d31f53e00e04f0c65f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_CAP_MU_BUF_SHIFT&#160;&#160;&#160;18</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac38dc05be5838d350c88ea8f919bc154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_dma_to_host_master </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poll_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_dma_to_host_master</p>
<p>Owns an MU buffer and its transfer to the host</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll_interval</td><td>number of ticks to wait when polling</td></tr>
  </table>
  </dd>
</dl>
<p>Need at least one thread per active MU buffer, possibly 2</p>
<p>Can be shared with other thread types, and can run on any island Consumes ~5% CPU</p>
<p>packet_capture_dma_to_host_master</p>
<p>This thread takes control of an MU buffer after it starts to be used, and manages DMA of the whole buffer over time to the host.</p>
<p>It starts operating when it receives an MU buffer from the first allocator, using the mu_buf_in_use work queue.</p>
<p>It monitors the bit-mask of packets ready in the MU buffer. It then packages up DMAs for slaves: PCIe base, MU base, first packet, number of packets, and presents them as work to DMA slave threads. When the MU buffer is completed and all the DMA threads complete the MU buffer can be recycled.</p>
<p>It has a 'first packet' which is set to 0 initially. It monitors up to 64 bits from 'first packet' of the bitmask of completed packets. When the bit for 'first packet' is set, it counts the number of consecutive set bits from that one upwards, and adds a DMA of that size (therefore of up to 64 packets). It then moves on 'first_packet'</p>
<p>If the bit is not set for 'first packet', the thread reads 'total_packets'; this is set when the receivers complete using the MU buffer. If 'first packet' is equal to 'total_packets' then the buffer is done; if not, sleep and poll the bitmask again.</p>
<p>When the buffer is done, the thread waits for all the DMAs to complete and then the MU buffer is recycled </p>

</div>
</div>
<a class="anchor" id="a5fee0ed8d1070c21657db8526b864c2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_dma_to_host_slave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_dma_to_host_slave</p>
<p>Owns a DMA to the host</p>
<p>Need at least four threads per active MU buffer Consumes ~5% CPU</p>
<p>Can be shared with other thread types, and can run on any island</p>
<p>packet_capture_dma_to_host_slave - 292i + 5450d (128 64B pkt/10 1.5kB pkt) 20i + 20i + 300d + 8*28i + 8*100d + 8*500d + 1*28i + 1*100d + 1*250d for 16kB transfer = 292i + 5450d</p>
<p>At most 64 packets - need to redo a bit of calculation here for 128 64B packets (2us), or for 10 1.5kB packets (3us?)</p>
<p>Takes ~5% CPU per thread at full load</p>
<p>The DMA threads put themselves on the DMA work queue, and take the data from the DMA master thread. They issue a DMA (or number of DMAs) to move the packet data, and then they issue a DMA to move the packet descriptor data. When the DMAs complete they increment the 'dmas complete' in the master thread structure and add themselves back to the DMA work queue. </p>

</div>
</div>
<a class="anchor" id="aa7303aefb6531f876f7eb4af246e5d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_fill_mu_buffer_list </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mu_base_s8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_fill_mu_buffer_list</p>
<p>Fill the MU buffer list with 'num_buf' 256kB buffers starting at given base</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mu_base_s8</td><td>MU buffer base address &gt;&gt; 8 </td></tr>
    <tr><td class="paramname">num_buf</td><td>Number of 256kB buffers to fill with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa499134067603cf522c681cebdb1b98a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_dma_to_host_master </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_dma_to_host_master</p>
<p>Perform initialization for the DMA to host master</p>
<p>Writes configuration of the MU_BUF_RECYCLE, TO_HOST_DMA and MU_BUF_IN_USE queues </p>

</div>
</div>
<a class="anchor" id="aec4a68d318b96f54e5337448669bc33f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_dma_to_host_slave </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_dma_to_host_slave</p>
<p>Perform initialization for the DMA to host slave</p>
<p>Gets TO_HOST_DMA queue configuration for the thread </p>

</div>
</div>
<a class="anchor" id="a4df596ec8a6328c4b0d58ed1f53594c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_mu_buffer_recycler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_mu_buffer_recycler</p>
<p>Perform initialization for the MU buffer recycler</p>
<p>Writes configuration of the MU_BUF_ALLOC queue Gets queue configuration required by the threads </p>

</div>
</div>
<a class="anchor" id="a7f85b25fa490ab889e8953f6984c01a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__intrinsic void packet_capture_init_pkt_rx_dma </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_init_pkt_rx_dma</p>
<p>Perform initialization for the packet rx DMA threads</p>
<p>Gets queue configuration required by the threads </p>

</div>
</div>
<a class="anchor" id="a3effacd61c93774284887a5d8aac9045"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_mu_buffer_recycler </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poll_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_mu_buffer_recycler</p>
<p>One thread required per system per MU buffer pool</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll_interval</td><td>number of ticks to wait when polling</td></tr>
  </table>
  </dd>
</dl>
<p>packet_capture_mu_buffer_recycler - ?</p>
<p>Get PCIe buffers from the host, collect with recycled buffers, then add them to the muq_mu_buf_alloc workq.</p>
<p>If an MU buffer lasts for 1k 64B packets then this needs to run every ~8k cycles.</p>
<p>If an MU buffer lasts for 256kB=2Mbits of data then this needs to run every ~20k cycles.</p>
<p>The max utilization of the ME is &lt;1%. </p>

</div>
</div>
<a class="anchor" id="af3f193d7f6136fb8f88b56b63ecf6fee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void packet_capture_pkt_rx_dma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>poll_interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>packet_capture_pkt_rx_dma</p>
<p>Handle packet received by CTM; claim next part of MU buffer, DMA the packet in, then pass on to work queue and free the packet</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poll_interval</td><td>number of ticks to wait when polling</td></tr>
  </table>
  </dd>
</dl>
<p>packet_capture_pkt_rx_dma - 89i + 707d + pktB/4 10i + 200d + 40i + 157d + 16i + 150d + 100d + pktB/4 + 16i + 100d + 7i Estimate of 1 thread does 1Mpps max, 8 thread can run per ME</p>
<p>Need 64 threads for min pkt 40GbE, spread across many CTM for bandwidth sharing Could remove DMA credit handling if &lt;64 threads per CTM</p>
<p>Handle packet received by CTM; claim next part of MU buffer, DMA the packet in, then pass on to work queue and free the packet </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 20 2016 15:36:17 for NFP Example Software by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
